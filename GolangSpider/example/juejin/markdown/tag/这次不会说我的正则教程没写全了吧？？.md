# 这次不会说我的正则教程没写全了吧？？ #

![](https://user-gold-cdn.xitu.io/2018/9/16/165e312bb8455715?imageView2/0/w/1280/h/960/ignore-error/1)

由于上一篇文章： [《正则表达式真的很骚，可惜你不会写！！！》]( https://juejin.im/post/5b96a8e2e51d450e6a2de115 ) 发表之后，不少网友说怎么没讲断言没讲反向没讲贪婪….，甚至有老铁说我裤子都脱了你就给讲了一点，哈哈哈，好吧，趁着山竹台风被迫放假在家的时间，把正则剩余的一些知识点给讲一下，希望大家喜欢，希望这次脱裤子阅读的老铁可以畅快的操作了。

本文旨在用最通俗的语言讲述最枯燥的基本知识。

> 
> 
> 
> 文章提纲：
> 
> * 零宽断言
> * 捕获和非捕获
> * 反向引用
> * 贪婪和非贪婪
> * 反义
> 

### 1. 零宽断言 ###

无论是零宽还是断言，听起来都古古怪怪的，
那先解释一下这两个词。

> 
> * 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
> 意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
> * 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
> 

意思是讲明白了，那他有什么用呢？
我们来举个栗子：
假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构

` 1 " < span class = "read-count" > 阅读数：641 </ span > "
复制代码`

其中只有‘641’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果使用正则应该怎么匹配呢？

下面先讲一下几种类型的断言：

> 
> * 正向先行断言（正前瞻）：
> 
> 
> * 语法：（?=pattern）
> * 作用：匹配pattern表达式的前面内容，不返回本身。
> 
> 
> 

这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘</span>’前面的数字内容
按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=</span>) 就可以匹配到前面的内容了。
匹配什么内容呢？如果要所有内容那就是：

` 1 String reg= ".+(?=</span>)" ;
2
3 String test = "<span class=\"read-count\">阅读数：641</span>" ;
4 Pattern pattern = Pattern.compile(reg);
5 Matcher mc=    pattern.matcher(test);
6 while (mc.find()){
7 System.out.println( "匹配结果：" )
8 System.out.println(mc.group());
9 }
10
11 //匹配结果：
12 //<span class="read-count">阅读数：641
复制代码`

可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：

` 1 String reg= "\\d+(?=</span>)" ;
2 String test = "<span class=\"read-count\">阅读数：641</span>" ;
3 Pattern pattern = Pattern.compile(reg);
4 Matcher mc=    pattern.matcher(test);
5 while (mc.find()){
6 System.out.println(mc.group());
7 }
8 //匹配结果：
9 //641
复制代码`

大功告成！

> 
> * 正向后行断言（正后顾）:
> 
> 
> * 语法：（?<=pattern）
> * 作用：匹配pattern表达式的后面的内容，不返回本身。
> 
> 
> 

有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。
上面的栗子，我们也可以用后行断言来处理.

` 1 //(?<=<span class="read-count">阅读数：)\d+
2 String reg= "(?<=<span class=\"read-count\">阅读数：)\\d+" ;
3
4 String test = "<span class=\"read-count\">阅读数：641</span>" ;
5 Pattern pattern = Pattern.compile(reg);
6 Matcher mc=    pattern.matcher(test);
7 while (mc.find()){
8 System.out.println(mc.group());
9 }
10 //匹配结果：
11 //641
复制代码`

就这么简单。

> 
> * 负向先行断言（负前瞻）
> 
> 
> * 语法：(?!pattern)
> * 作用：匹配非pattern表达式的前面内容，不返回本身。
> 
> 
> 

有正向也有负向，负向在这里其实就是非的意思。
举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”
现在要找到不是'的花朵'前面的祖国
用正则就可以这样写：

` 1 祖国(?!的花朵)
复制代码`
> 
> * 负向后行断言（负后顾）
> 
> 
> * 语法：(?<!pattern)
> * 作用：匹配非pattern表达式的后面内容，不返回本身。
> 
> 
> 

### 2. 捕获和非捕获 ###

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

> 
> 
> 
> 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
> 
> 

而根据命名方式的不同，又可以分为两种组：

> 
> * 数字编号捕获组：
> 语法：(exp)
> 解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
> 比如固定电话的：020-85653333
> 他的正则表达式为：(0\d{2})-(\d{8})
> 按照左括号的顺序，这个表达式有如下分组：
> 

+------+------+------------------+--------------+
| 序号 | 编号 |       分组       |     内容     |
+------+------+------------------+--------------+
|    0 |    0 | (0\d{2})-(\d{8}) | 020-85653333 |
|    1 |    1 | (0\d{2})         |          020 |
|    2 |    2 | (\d{8})          |     85653333 |
+------+------+------------------+--------------+

我们用Java来验证一下：

` 1 String test = "020-85653333" ;
2 String reg= "(0\\d{2})-(\\d{8})" ;
3 Pattern pattern = Pattern.compile(reg);
4 Matcher mc= pattern.matcher(test);
5 if (mc.find()){
6 System.out.println( "分组的个数有：" +mc.groupCount());
7 for ( int i= 0 ;i<=mc.groupCount();i++){
8 System.out.println( "第" +i+ "个分组为：" +mc.group(i));
9 }
10 }
复制代码`

输出结果：

` 1 分组的个数有： 2
2 第 0 个分组为： 020 -85653333
3 第 1 个分组为： 020
4 第 2 个分组为： 85653333
复制代码`

可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。

> 
> * 命名编号捕获组：
> 语法：(?<name>exp)
> 解释：分组的命名由表达式中的name指定
> 比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
> 按照左括号的顺序，这个表达式有如下分组：
> 

+------+-------+------------------+--------------+
| 序号 | 名称  |       分组       |     内容     |
+------+-------+------------------+--------------+
|    0 |     0 | (0\d{2})-(\d{8}) | 020-85653333 |
|    1 | quhao | (0\d{2})         |          020 |
|    2 | haoma | (\d{8})          |     85653333 |
+------+-------+------------------+--------------+

用代码来验证一下：

` 1 String test = "020-85653333" ;
2 String reg= "(?<quhao>0\\d{2})-(?<haoma>\\d{8})" ;
3 Pattern pattern = Pattern.compile(reg);
4 Matcher mc= pattern.matcher(test);
5 if (mc.find()){
6 System.out.println( "分组的个数有：" +mc.groupCount());
7 System.out.println(mc.group( "quhao" ));
8 System.out.println(mc.group( "haoma" ));
9 }
复制代码`

输出结果：

` 1 分组的个数有： 2
2 分组名称为:quhao,匹配内容为： 020
3 分组名称为:haoma,匹配内容为： 85653333
复制代码`
> 
> * 非捕获组：
> 语法：(?:exp)
> 解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
> 

比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

` 1 (?:\ 0 \d{2})-(\d{8})
复制代码`

+------+------+------------------+--------------+
| 序号 | 编号 |       分组       |     内容     |
+------+------+------------------+--------------+
|    0 |    0 | (0\d{2})-(\d{8}) | 020-85653333 |
|    1 |    1 | (\d{8})          |     85653333 |
+------+------+------------------+--------------+

验证一下：

` 1 String test = "020-85653333" ;
2 String reg= "(?:0\\d{2})-(\\d{8})" ;
3 Pattern pattern = Pattern.compile(reg);
4 Matcher mc= pattern.matcher(test);
5 if (mc.find()){
6 System.out.println( "分组的个数有：" +mc.groupCount());
7 for ( int i= 0 ;i<=mc.groupCount();i++){
8 System.out.println( "第" +i+ "个分组为：" +mc.group(i));
9 }
10 }
复制代码`

输出结果：

` 1 分组的个数有： 1
2 第 0 个分组为： 020 -85653333
3 第 1 个分组为： 85653333
复制代码`

### 3. 反向引用 ###

上面讲到捕获，我们知道： **捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用** 。

根据捕获组的命名规则，反向引用可分为：

> 
> * 数字编号组反向引用：\k或\number
> * 命名编号组反向引用：\k或者\'name'
> 

好了 讲完了，懂吗？不懂！！！
可能连前面讲的捕获有什么用都还不懂吧？
其实只是看完捕获不懂不会用是很正常的！
因为捕获组通常是和反向引用一起使用的

上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用
注意两个字眼：“内容” 和 “使用”
这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住
那这里所说的“使用”是怎样使用呢？

因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。

还是举栗子吧：
比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母
如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，
现在我们先用程序思维理一下思路：

> 
> 
> 
> * 1）匹配到一个字母
> * 2）匹配第下一个字母，检查是否和上一个字母是否一样
> * 3）如果一样，则匹配成功，否则失败
> 
> 
> 

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件
好了，有思路就要实践
首先匹配一个字母：\w
我们需要做成分组才能捕获，因此写成这样：(\w)

那这个表达式就有一个捕获组：（\w）
然后我们要用这个捕获组作为条件，那就可以：(\w)\1
这样就大功告成了
可能有人不明白了，\1是什么意思呢？
还记得捕获组有两种命名方式吗， **一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**
**在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的**
因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1
当然，通常都是是后者。
我们来测试一下：

` 1 String test = "aabbbbgbddesddfiid" ;
2 Pattern pattern = Pattern.compile( "(\\w)\\1" );
3 Matcher mc= pattern.matcher(test);
4 while (mc.find()){
5 System.out.println(mc.group());
6
7 }
复制代码`

输出结果：

` 1 aa
2 bb
3 bb
4 dd
5 dd
6 ii
复制代码`

嗯，这就是我们想要的了。
在举个替换的例子，假如想要把字符串中abc换成a

` 1 String test = "abcbbabcbcgbddesddfiid" ;
2 String reg= "(a)(b)c" ;
3 System.out.println(test.replaceAll(reg, "$1" ));;
复制代码`

输出结果：

` 1 abbabcgbddesddfiid
复制代码`

### 4. 贪婪和非贪婪 ###

##### 1.贪婪 #####

我们都知道，贪婪就是不满足，尽可能多的要。
在正则中，贪婪也是差不多的意思:

> 
> 
> 
> 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
> 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
> 
> 
> 

前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：

` 1 \d{3,6}
复制代码`

用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。
如

` 1 String reg= "\\d{3,6}" ;
2 String test= "61762828 176 2991 871" ;
3 System.out.println( "文本：" +test);
4 System.out.println( "贪婪模式：" +reg);
5 Pattern p1 =Pattern.compile(reg);
6 Matcher m1 = p1.matcher(test);
7 while (m1.find()){
8 System.out.println( "匹配结果：" +m1.group( 0 ));
9 }
复制代码`

输出结果：

` 1 文本： 61762828 176 2991 44 871
2 贪婪模式：\d{3,6}
3 匹配结果： 617628
4 匹配结果： 176
5 匹配结果： 2991
6 匹配结果： 871
复制代码`

由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。
一个量词就如此贪婪了，
那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

> 
> 
> 
> 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。
> 
> 
> 

` 1 String reg= "(\\d{1,2})(\\d{3,4})" ;
2 String test= "61762828 176 2991 87321" ;
3 System.out.println( "文本：" +test);
4 System.out.println( "贪婪模式：" +reg);
5 Pattern p1 =Pattern.compile(reg);
6 Matcher m1 = p1.matcher(test);
7 while (m1.find()){
8 System.out.println( "匹配结果：" +m1.group( 0 ));
9 }
复制代码`

输出结果：

` 1 文本： 61762828 176 2991 87321
2 贪婪模式：(\d{1,2})(\d{3,4})
3 匹配结果： 617628
4 匹配结果： 2991
5 匹配结果： 87321
复制代码`
> 
> * “617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628
> * "2991" 是前面的\d{1,2}匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)
> * "87321"是前面的\d{1,2}匹配出了87，后面的匹配出了321
> 

##### 2. 懒惰（非贪婪） #####

> 
> 
> 
> 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
> 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。
> 
> 
> 

懒惰量词是在贪婪量词后面加个“？”

+--------+---------------------------------+
|  代码  |              说明               |
+--------+---------------------------------+
| *?     | 重复任意次，但尽可能少重复      |
| +?     | 重复1次或更多次，但尽可能少重复 |
| ??     | 重复0次或1次，但尽可能少重复    |
| {n,m}? | 重复n到m次，但尽可能少重复      |
| {n,}?  | 重复n次以上，但尽可能少重复     |
+--------+---------------------------------+

` 1 String reg= "(\\d{1,2}?)(\\d{3,4})" ;
2 String test= "61762828 176 2991 87321" ;
3 System.out.println( "文本：" +test);
4 System.out.println( "贪婪模式：" +reg);
5 Pattern p1 =Pattern.compile(reg);
6 Matcher m1 = p1.matcher(test);
7 while (m1.find()){
8 System.out.println( "匹配结果：" +m1.group( 0 ));
9 }
复制代码`

输出结果：

` 1 文本： 61762828 176 2991 87321
2 贪婪模式：(\d{1,2}?)(\d{3,4})
3 匹配结果： 61762
4 匹配结果： 2991
5 匹配结果： 87321
复制代码`

解答：

> 
> 
> 
> “61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762
> "2991" 是左边的懒惰匹配出2，右边的贪婪匹配出991
> "87321" 左边的懒惰匹配出8，右边的贪婪匹配出7321
> 
> 

### 5. 反义 ###

前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

+----------+--------------------------------------------+
|  元字符  |                    解释                    |
+----------+--------------------------------------------+
| \W       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S       | 匹配任意不是空白符的字符                   |
| \D       | 匹配任意非数字的字符                       |
| \B       | 匹配不是单词开头或结束的位置               |
| [^x]     | 匹配除了x以外的任意字符                    |
| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符      |
+----------+--------------------------------------------+

正则进阶知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常6的正则，还有很远的距离，只有真正对它感兴趣的，并且经常研究和使用它，才会渐渐的理解它的博大精深之处，我就带你们走到这，剩下的，靠自己啦。

觉得本文对你有帮助？请分享给更多人 关注「编程无界」，提升装逼技能

![](https://user-gold-cdn.xitu.io/2018/9/16/165e3139019de6fe?imageView2/0/w/1280/h/960/ignore-error/1)